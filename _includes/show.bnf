    show ::= "show" setting*  [ exports ] [ java_generated_class ]
    	     ( segment | feature | rc_handler | named_command 
		   | mosaic_hint | show_top )* 
    	     "end_show"

    setting ::=    segment_stack_depth_setting 
                 | draw_targets_setting
		 | sticky_images_setting
		 | binary_grin_file_setting 
		 | grinview_background_setting

    segment_stack_depth_setting := "setting" "segment_stack_depth" integer ";"

    draw_targets_setting ::= "setting" "draw_targets" "{" string* "}" ";"
    	# If this isn't set, it defaults to { T:Default }

    sticky_images_setting ::= "setting" "sticky_images" "{" string* "}" ";"
	# This sets the list of file names for the images that are to be
	# "sticky".  Sticky images aren't unloaded, even when no feature
	# that uses them is in the the setup or active clause of the
	# active segment.  Thus, the first time a sticky image is
	# prepared it is loaded normally, but subsequent prepares happen
	# instantly.

    binary_grin_file_setting ::= "setting" "binary_grin_file" string ";"
	# Sets the file name of the binary grin file that's produced by
	# the compiler.  This can be used to make the extension be ".grn"
	# instead of ".grin".

    grinview_background_setting 
	::= "setting" "grinview_background" "{" grinview_background* "}" ";"

    grinview_background ::= string
	# An image file name.  
        
    show_top ::= "show_top" string ;
        # Sets the name of show's top node for rendering.
        # The string should correspond to one of the feature names
        # in this show.  When the show_top element is present, then
        # a showtop_group feature should also be defined in the show.
        # This can be used to add a special effect to the show tree.

    exports ::= "exports" "segments" name_list
    			"features" name_list
			"handlers" name_list
			[ "named_commands" name_list ]
			";"
	# If this isn't set, then everything is public
	# The names in name_list may contain wildcards like
	# "*", "?", "[wxz]" and "[1-5]".
         
    java_generated_class ::= "java_generated_class" name "[[" java_source "]]"
        # This contains the full text of the class declaration.  The class
        # must extend com.hdcookbook.grin.commands.ShowCommands, and must
        # contain the string JAVA_COMMAND_BODY.  JAVA_COMMAND_BODY gets
        # replaced with the automatically-generated method execute() and
        # the methods grinCommandNN() for each command.
    
    java_source ::= string*
        # May contain the special sequences:
        #   XLET_ONLY_[[ java_source ]]
        #   GRINVIEW_ONLY_[[ java_source ]]
        #   GRIN_COMMAND_[[ command ]]
	# 
	# See the comments at the end of the main class documentation of
	# com.hdcookbook.grin.GrinXHelper for comments on how these are
	# used, and for the Abstract Director pattern that can also be used
	# to make xlets that work under GrinView.

    segment ::= "segment" name ["active" feature_list] ["setup" feature_list]
    			[ "rc_handlers" name_list ]
			[ "on_entry" commands ]
			[ ( "next" | "setup_done")  commands]  ";"


    feature_list ::= name_list

    feature ::= fixed_image | image_sequence | box | assembly | menu_assembly
    		  | sound | text | translator_model | translator | group 
		  | timer | clipped | src_over | fade | scaling_model
		  | guarantee_fill | set_target | showtop_group
		  | extension_feature | extension_modifier

    fixed_image ::= "feature" "fixed_image" name image_placement file_name 
    		        [ "scaling_model" name ] ";"

    image_sequence ::= "feature" "image_sequence" name image_seq_placement
		         file_name "{" name_or_continuation * "}" 
			 	   extension [ "repeat" ]
    		       [ "scaling_model" name ]
		       ( "model" feature_name | image_seq_end ) ";"
	    # "linked_to" is accepted for "model", for backwards compatibility.
	    # In both cases, the model, if specified,  must be a different 
	    # image_sequence with the same number of images in the sequence.

    image_seq_placement ::= image_placement | "{" image_placement* "}"
    	    # if there is a list of image placements in a image_sequence,
	    # it must have the same length as the images array.

    image_seq_end ::= [ loop_count ] [ "end_commands" commands ]

    image_placement ::= x y | "(" im_x im_y [ "scale" x y "mills" ] ")"
	    # A scale factor or -1000 in either or both directions can be
	    # used to filp the image.  A scale factor other than 1000 
	    # or -1000 may be slow at runtime on some players.

    im_x ::= ( "left" | "middle" | "right" ) x
    im_y ::= ( "top" | "middle" | "bottom" ) y

    box ::= "feature" "box" name rectangle
    		[ "outline" width color_value ]
		[ "fill" color_value ]
	        [ "scaling_model" name ] ";"

    name_or_continuation ::= "+" | "-" | name	# "+" means "repeat last frame",
     						# "-" means "empty"

    assembly ::= "feature" "assembly" name "{" assembly_part * "}" ";"

    assembly_part ::= name sub_feature

    menu_assembly ::= "feature" "menu_assembly" name
    				"template" "{" menu_assembly_features * "}"
				"parts" "{" menu_assembly_part "}" ";"

    menu_assembly_features ::= id "{" sub_feature * "}"

    menu_assembly_part ::= name "{" menu_assembly_features * "}"

	# For a menu_assembly, the template features provide a "base" set 
	# of features included in each part (each branch).  Then,  each 
	# branch defines an assembly part name, and the specifies what 
	# is to be replaced out of that template for the given branch.
	#
	# A menu_assembly is converted into a normal assembly with a bunch
	# of automatically-generated anonymous groups as its parts.

    text ::= "feature" "text" name text_pos text_strings font_spec color_spec 
    		[ "background" color_entry ] ";"

    text_pos ::= [ "left" | "middle" | "right" ] x
    		 [ "top" | "baseline" | "bottom" ] y

    text_strings ::= string | "{" string * "}" [ "vspace" integer ]

    font_spec ::= font_name font_style font_size 

    font_style ::= "plain" | "bold" | "italic" | "bold-italic"

    font_size ::= int		# Size in points (which is the same as pixels)

    color_spec ::= "{" color_entry * "}"  [ loop_count ]

    color_entry ::= "+" | color_value

    loop_count ::= "loop_count" ( "infinite" | integer )

    group ::= "feature" "group" name "{" sub_feature * "}" ";"

    timer ::= "feature" "timer" name num_frames [ "repeat" ] commands ";"

    clipped ::= "feature" "clipped" name sub_feature rectangle ";"

    src_over ::= "feature" "src_over" name sub_feature ";"

    fade ::= "feature" "fade" name sub_feature
    		[ "src_over" ] "{" ( frame_number alpha_int tween_type ) * "}" 
		[ "repeat" frame_number ] 
		[ loop_count ]
		[ "end_commands" commands ] ";"

    scaling_model ::= "feature" "scaling_model" name 
		"{" scale_key_frame* "}"
		[ "repeat" frame_number ] 
		[ loop_count ]
		[ "end_commands" commands ] ";"
	# There must be >= 1 scale_key_frame
    
    scale_key_frame ::=  frame_number x y x_scale y_scale [ tween_type ] "mills"
    	# The first frame must be zero
	# The scale factor is in mills (1/1000); a factor of 1000 is 1:1 scale
	# The x,y values are the anchor point for the scaling operation.  
	#     Scaled objects get bigger and smaller, centered at this anchor
	#     point.  You can also think of it as the "origin for scaling."

    key_frame ::= frame_number x y interpolation_type

    guarantee_fill ::= "feature" "guarantee_fill" name sub_feature
    				rectangle 	    # guaranteed area
				{ rectangle * } ";" # areas to be cleared

    set_target ::= "feature" "set_target" name sub_feature target_name ";"

    target_name ::= name

    translator_model ::= "feature" "translator_model" name 
			    "{" trans_key_frame * "}" 
			    [ "repeat" frame_number ] 
			    [ loop_count ]
			    [ "end_commands" commands ] ";"
	# "translator_model" can be replaced by the old name "translation"
	#
	# If you want to set the x,y position programmatically, just have
	# one key frame.
        # Use "offscreen" keyword for x,y position to place a feature 
        # off the screen without causing the animation engine to repaint extra
        # region.  Use Integer.MIN_VALUE for x,y position to off-screen 
        # programatically. 

    trans_key_frame ::= frame_number x y trans_tween

    trans_tween ::=    "linear-relative"  [ "max-error" integer ]
    		     | tween_type
    	# linear and linear-relative are special for translations.  You
	# should always use linear-relative; that's linear interpolation
	# using relative coordinates for the child nodes (that is, the
	# interpolation specifies delta-x and delta-y for each child).
	#
	# "linear" is deprecated, and is kept for backwards compatibility
	# with old show files.  In "linear", the coordinates are absolute
	# coordinates for the upper-left hand corner of the children.  
	# Trying to do this this was a bad idea - it's not always possible
	# to determine the upper-left hand corner of the children.  When it's
	# not, the compiler will report an error that suggests switching
	# to linear-relative.

    tween_type ::=
              "linear"  [ "max-error" integer ]
	    | "start"
	    | "ease-in-quad" [ "max-error" integer ]
	    | "ease-out-quad" [ "max-error" integer ]
	    | "ease-in-out-quad" [ "max-error" integer ]
	    | "ease-in-cubic" [ "max-error" integer ]
	    | "ease-out-cubic" [ "max-error" integer ]
	    | "ease-in-out-cubic" [ "max-error" integer ]
	    | "ease-in-quart" [ "max-error" integer ]
	    | "ease-out-quart" [ "max-error" integer ]
	    | "ease-in-out-quart" [ "max-error" integer ]
	    | "ease-in-quint" [ "max-error" integer ]
	    | "ease-out-quint" [ "max-error" integer ]
	    | "ease-in-out-quint" [ "max-error" integer ]
	    | "ease-in-sine" [ "max-error" integer ]
	    | "ease-out-sine" [ "max-error" integer ]
	    | "ease-in-out-sine" [ "max-error" integer ]
	    | "ease-in-expo" [ "max-error" integer ]
	    | "ease-out-expo" [ "max-error" integer ]
	    | "ease-in-out-expo" [ "max-error" integer ]
	    | "ease-in-circ" [ "max-error" integer ]
	    | "ease-out-circ" [ "max-error" integer ]
	    | "ease-in-out-circ" [ "max-error" integer ]
	    | "ease-in-elastic" [ "amplitude" double ] [ "period" double ] 
	    			[ "max-error" integer ]
	    | "ease-out-elastic" [ "amplitude" double ] [ "period" double ] 
	    			 [ "max-error" integer ]
	    | "ease-in-out-elastic" [ "amplitude" double ] [ "period" double ] 
	    			    [ "max-error" integer ]
	    | "ease-in-back" [ "overshoot" double ] [ "max-error" integer ]
	    | "ease-out-back" [ "overshoot" double ] [ "max-error" integer ]
	    | "ease-in-out-back" [ "overshoot" double ] [ "max-error" integer ]
	    | "ease-in-bounce" [ "max-error" integer ]
	    | "ease-out-bounce" [ "max-error" integer ]
	    | "ease-in-out-bounce" [ "max-error" integer ]
	    | "ease-points" "{" tween-point * "}" [ "max-error" integer ]
        # The tween type give the algorithm used for the transition from the
	# previous key frame to the present one.
	#
	# start is a synonym for linear.  It's intended to be
	# used for the first keyframe, since the tween type for the
	# first keyframe is meaningless.
	#
	# The other tweening types are described in 
	# com.robertpenner.PennerEasing, and in his book, which you can
	# find out about at http://robertpenner.com.
	#
	# max-error says how many units of error you're willing to tolerate
	# when the compiler uses linear interpolation segments to approximate
	# tweening.  It defaults to 0, that is, no error.  Setting a higher
	# tolerance will result in a smaller .grin file and less runtime
	# memory usage.  The grin compiler tells you how many key frames
	# are added for interpolation due to tweening; if the number looks
	# huge, consider increasing the error tolerance.

    tween_point ::= "(" integer * ")"

    translator ::= "feature" "translator" name translator_model_name 
    			"{" sub_feature "}" ";"
                        
    showtop_group :: "feature" "showtop_group" name ";"
        # This can be used to give a name to the group of features
        # that represents a set of active features at runtime.
        # When a segment in this show is activated, it's active features
        # get slotted into this group.  See also "show_top".

    extension_feature ::= "feature" "extension" namespace:type_name name 
    			  <syntax of extension> ";"

    modifier_feature ::= "feature" "modifier" namespace:type_name name 
    				sub_feature string ";"

    name_list ::= "{" name * "}"


    commands ::= "{" command * "}"

    command ::= activate_segment | activate_part | segment_done 
    		    | deprecated_invoke_assembly_cell | set_visual_rc_state
		    | reset_feature | sync_display | run_named_commands
		    | other_command | java_command

    activate_segment ::= "activate_segment" segment_name [ "&lt;push&gt;" ] ";"
    			 | "activate_segment" "&lt;pop&gt;"  ";"

    activate_part ::= "activate_part" assembly_name part_name ";"

    segment_done ::= "segment_done" ";"

    deprecated_invoke_assembly_cell 
        ::= "invoke_assembly" ("selected_cell" | "cell" x y) handler_name ";"
    # This has been replaced by set_visual_rc_state

    set_visual_rc_state
	 ::= "set_visual_rc" handler_name 
	 	("state" state_name | "current")
	        ("selected" | "activated") 
		[ "grid_alternate" name ]
                [ "run_commands" ] ";"
    #
    # grid_alternate can be used to swap in a different grid in the visual
    # RC handler.  See the "visual_grid_alternates" part of visual_rc_handler
    #

    reset_feature ::= "reset_feature" feature_name ";"

    sync_display ::= "sync_display" ";"

    run_named_commands ::= "run_named_commands" name ";"

    other_command ::= namespace:type_name
    				(syntax as determined by director) ";"
	#  The custom command shouldn't include a ";" token.  If it does,
	#  testing with GenericMain will be more difficult.
         
    java_command ::= "java_command" "[[" java_source "]]"

    rc_handler ::=  visual_rc_handler | command_rc_handler
                    | deprecated_assembly_grid_handler ";"

    visual_rc_handler
	::= "rc_handler" "visual" name
		( visual_rc_grid | visual_grid_alternates )
	        [ "assembly" assembly_name [ "start_selected" boolean ] ]
	        "select" action_by_state
	        "activate" action_by_state
	        [ "mouse" mouse_locations ]
	        [ "timeout" integer "frames" commands ]  ";"
	# start_selected defaults false.  If true, when the handler is
	# activated, if the assembly is in one of the activated states, it
	# will be taken to the corresponding selected state.

    visual_rc_grid ::= "grid" visual_grid [ "rc_override" visual_overrides ]

    visual_grid ::= "{" visual_grid_row * "}"

    visual_grid_row ::= "{" visual_grid_entry * "}"

    visual_grid_entry ::= state_name | "[" state_name "]" 
    			  | "(" x y ")" | "<activate>"
			  | "<wall>" | "<null>"
	    # <activate> means "make the assembly activated"
	    # <wall> means "if cell navigated to, stay in current state"
	    # <null> means "it's an error if this cell can be navigated to"
	    # The "( x y )" syntax is deprecated.  When such a cell is
	    #   navigated to, it goes to the state that is located at
	    #   the cell x,y (counting from 0).  The same effect can be
	    #   achieved in a clearer way with the "[ state_name ]" syntax.

    visual_grid_alternates ::= "grid_alternates" "{" visual_grid_alternate * "}"
	    # see also the visual_grid_alternate parameter to the
	    # set_visual_rc command.  This lets you swap in a different
	    # grid, e.g. to disable certain buttons.  By default the first
	    # grid is active.  The active grid can ge changed by the
	    # set_visual_rc command, or from Java.

    visual_grid_alternate ::= name visual_grid_with_override

    visual_grid_with_override ::= 
    	    "{" ( visual_grid_entry * ) [ "rc_override" visual_overrides ] "}"

    visual_overrides ::= "{" visual_override * "}"

    visual_override ::= "{" state_name visual_override_direction state_name "}"
	# When in the first state, the given key will transition to the
	# second state
    
    visual_override_direction ::= "up" | "down" | "left" | "right"

    action_by_state ::= "{" state_and_action * "}"

    state_and_action ::= state_name visual_action

    visual_action ::= part_name | commands | part_name commands

    mouse_locations ::= "{" ( state_name rectangle ) * "}"
    	# It's OK to have more than one rectangle for a given state

    deprecated_assembly_grid_handler 
	::= "rc_handler" "assembly_grid" name
	        "assembly" assembly_name
		"select" part_name_matrix 
		"invoke" part_name_matrix
		[ "timeout" integer "frames" commands ] 
		[ "when_invoked" "{" invoked_commands * "}" ] ";"

    part_name_matrix ::= "{" part_name_list * "}"

    invoked_commands ::= part_name commands

    part_name_list ::= "{" part_name * "}"

    command_rc_handler ::= "rc_handler" [ "key_pressed" | "key_released" ]
    				name "{" rc_key * "}" 
    				"execute" commands ";"
	#  Note that only key_pressed is guaranteed to be available
	#  on all devices.  OCAP and MHP don't guarantee key_released, and
	#  BD part J.1.2 looks like it's not guaranteed in BD-J, either.

    rc_key ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
               | "right" | "left" | "up" | "down" | "enter"
	       | "red" | "green" | "yellow" | "blue" | "popup_menu"
	       | "play" | "stop" | "still_off" | "track_next"
	       | "track_prev" | "fast_fwd" | "rewind" | "pause"
	       | "secondary_video_enable_disable"
	       | "secondary_audio_enable_disable"
	       | "pg_textst_enable_disable"

    rectangle ::= "(" x y x y ")"	# upper left and lower right points
    					# inside rectangle

    color_value ::= "{" red_int green_int blue_int alpha_int "}"

    mosaic_hint ::= "mosaic_hint" name width height "{" file_name * "}" ";"
	# mosaic_hint is deprecated.  See "mosaics"

    named_command ::= "named_command" name commands ";"

    sub_feature ::= feature_name
    		    | "sub_feature" feature_without_name

    feature_without_name ::= ... exactly like feature, without the feature name

    segment_name ::= string
    feature_name ::= string
    assembly_name ::= string
    translator_model_name ::= string
    part_name ::= string
    state_name ::= string
    file_name ::= string
    font_name ::= string
    handler_name ::= string
    name ::= string
    id ::= string
    namespace:type_name ::= string containing ":"
    red_int ::= integer		    # 0..255
    green_int ::= integer	    # 0..255
    blue_int ::= integer	    # 0..255
    alpha_int ::= integer	    # 0..255, 0 is transparent, 255 is opaque
    num_frames ::= integer
    frame_number ::= integer
    width ::= integer
    x_scale ::= integer
    y_scale ::= integer
    x ::= integer
    y ::= integer
    boolean ::= "true" | "false"
